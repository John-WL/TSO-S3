C51 COMPILER V9.53.0.0   PROJETFINALMAIN                                                   12/05/2019 16:48:53 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE PROJETFINALMAIN
OBJECT MODULE PLACED IN ProjetFinalMain.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ProjetFinalMain.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS
                    -(2)

line level    source

   1          /**************************************************************************************************
   2          Nom du fichier: ProjetFinalMain.c
   3          Auteur: John-William Lebel
   4          Date de création: 2019-11-26
   5          
   6          Versions:
   7          0.1 -> Code base
   8          
   9          ***************************************************************************************************/
  10          
  11          // *************************************************************************************************
  12          //  INCLUDES
  13          // *************************************************************************************************  
  14          
  15          #include "_DS89C450Modifie.h"       // Définition des bits et des registres du microcontrôleur
  16          #include "_DeclarationGenerale.h"
  17          #include <stdio.h>          // Prototype de declarations des fonctions I/O  
  18          #include "I2C.h"            // I2C functions handling
  19          #include "RxTx232.h"        // RxTx232 functions handling
  20          #include "LCD.h"            // LCD functions handling
  21          #include "Timer0.h"         // Timer0 initialization handling
  22          #include "TypeConversion.h" // Fonctions useful when it comes to converting values between type representa
             -tions and/or types
  23          #include "ProjectDefinitions.h"
  24          #include "SubOptimizedLcdPrinter.h"
  25          #include "KeyboardI2C.h"
  26          #include "CircularBuffer_RxTx.h"
  27          #include "SequenceHandler.h"
  28          
  29          // *************************************************************************************************
  30          //  CONSTANTES
  31          // *************************************************************************************************
  32          
  33          // in "ProjectDefinitions.h"
  34          
  35          // *************************************************************************************************
  36          //  FONCTIONS LOCALES
  37          // *************************************************************************************************
  38          
  39          void printLcdDeltaCharacters(void);
  40          unsigned char readMemoryI2C(unsigned char* sequence, unsigned char* step, unsigned char armIndex);
  41          //void writeSequencesToMemoryI2C(void);     // only needed once when we'll fill up the memory
  42          
  43          // *************************************************************************************************
  44          //  STRUCTURES ET UNIONS
  45          // *************************************************************************************************
  46          
  47          // in "ProjectDefinitions.h"
  48          
  49          // *************************************************************************************************
  50          // VARIABLES GLOBALES
  51          // *************************************************************************************************
  52          
  53          struct ArmState currentArmState = { MIDDLE_POSITION,      // base starting position
C51 COMPILER V9.53.0.0   PROJETFINALMAIN                                                   12/05/2019 16:48:53 PAGE 2   

  54                                              MIDDLE_POSITION,      // shoulder starting position
  55                                              MIDDLE_POSITION,      // elbow starting position
  56                                              MIDDLE_POSITION,      // wrist starting position
  57                                              MAXIMUM_POSITION };   // grip starting position (open)
  58          
  59          struct Compteur stCompteur = {0, 0, 0};
  60          
  61          struct TramePIC trame = {{{0xFF, 0xFF}, 0xFF, 0xFF}, 0xFF};   // default readings
  62          unsigned char weightType = NONE_WEIGHT;                   // default to "no weight"
  63          struct KeyboardManualSettings keyboardManualSettings = {MOTOR_0, 5};  // defaultselected motor = base
  64                                                                                // and default manual speed is
  65                                                                                // set to an arbitrary value.
  66          struct SequenceStep currentSequenceIndexes = {0, 0};        // this is to store the current sequence
  67                                                                      // the arm is executing with two indexes:
  68                                                                      // "sequence" and "step". It probably needs
  69                                                                      // a better name... plz be charitable to the community much luv thx.
  70          
  71          unsigned char* connectionStateString = LCD_DELTA_OFFLINE_VALUE;
  72                                                                      // OffL/OnL. It's a variable storing the changes to print to the
  73                                                                      // lcd in case we lose contact with the exterior... 
  74          
  75          unsigned char lcdInitializationContent[4][21] = { {"1:66 2:66 3:66 4:66 "},
  76                                                            {"5:66 X:FF Y:FF P:FF "},
  77                                                            {"B:FF Poid:Aucun     "},
  78                                                            {"05 seq:0 step:0 OffL"} };
  79          
  80                // that stupid and massive array might be useful to fill up the I2C memory... just a thought
  81          unsigned char xdata sequences[7][10][5] = { { {0x0C, 0x4C, 0x1C, 0x51, 0x00},
  82                                                        {0x0C, 0x73, 0x1C, 0x51, 0x00},
  83                                                        {0x0C, 0x78, 0x23, 0x51, 0x00},
  84                                                        {0x0C, 0x78, 0x23, 0x51, 0xFF}, // position A6 sur le touchscreen
  85                                                        {0x0C, 0x78, 0x23, 0x51, 0xFF},
  86                                                        {0x0C, 0x78, 0x23, 0x51, 0xFF},
  87                                                        {0x0C, 0x78, 0x23, 0x51, 0xFF},
  88                                                        {0x0C, 0x78, 0x23, 0x51, 0xFF},
  89                                                        {0x0C, 0x78, 0x23, 0x51, 0xFF},
  90                                                        {0x0C, 0x78, 0x23, 0x51, 0xFF} }, 
  91          
  92                                                      { {0x11, 0x4C, 0x05, 0x4D, 0x00},
  93                                                        {0x11, 0x5E, 0x00, 0x4D, 0x00},
  94                                                        {0x11, 0x69, 0x0C, 0x4D, 0x00},
  95                                                        {0x11, 0x69, 0x0C, 0x4D, 0xFF}, // position B2 sur le touchscreen
  96                                                        {0x11, 0x69, 0x0C, 0x4D, 0xFF},
  97                                                        {0x11, 0x69, 0x0C, 0x4D, 0xFF},
  98                                                        {0x11, 0x69, 0x0C, 0x4D, 0xFF},
  99                                                        {0x11, 0x69, 0x0C, 0x4D, 0xFF},
 100                                                        {0x11, 0x69, 0x0C, 0x4D, 0xFF},
 101                                                        {0x11, 0x69, 0x0C, 0x4D, 0xFF} },
 102          
 103                                                      { {0x15, 0x4C, 0x13, 0x51, 0x00},
 104                                                        {0x15, 0x6B, 0x13, 0x51, 0x00},
 105                                                        {0x15, 0x75, 0x1E, 0x51, 0x00},
 106                                                        {0x15, 0x75, 0x1E, 0x51, 0xFF}, // position C5 sur le touchscreen
 107                                                        {0x15, 0x75, 0x1E, 0x51, 0xFF},
 108                                                        {0x15, 0x75, 0x1E, 0x51, 0xFF},
 109                                                        {0x15, 0x75, 0x1E, 0x51, 0xFF},
 110                                                        {0x15, 0x75, 0x1E, 0x51, 0xFF},
 111                                                        {0x15, 0x75, 0x1E, 0x51, 0xFF},
 112                                                        {0x15, 0x75, 0x1E, 0x51, 0xFF} },
 113          
 114                                                      { {0x0B, 0x64, 0x4A, 0x66, 0xFF},
 115                                                        {0x0B, 0x81, 0x39, 0x66, 0xFF},
C51 COMPILER V9.53.0.0   PROJETFINALMAIN                                                   12/05/2019 16:48:53 PAGE 3   

 116                                                        {0x0B, 0x81, 0x39, 0x66, 0x00}, // position balance
 117                                                        {0x0B, 0x81, 0x39, 0x66, 0x00},
 118                                                        {0x0B, 0x81, 0x39, 0x66, 0x00},
 119                                                        {0x0B, 0x81, 0x39, 0x66, 0x00},
 120                                                        {0x0B, 0x81, 0x39, 0x66, 0x00},
 121                                                        {0x0B, 0x81, 0x39, 0x66, 0x00},
 122                                                        {0x0B, 0x81, 0x39, 0x66, 0x00},
 123                                                        {0x0B, 0x81, 0x39, 0x66, 0x00} }, // position balance PINCE RELÂCHÉE (on fait comme
             -nt pour prendre des mesures sinon)
 124          
 125                                                      { {0x0B, 0x81, 0x39, 0x66, 0xFF}, // position balance (pince fermée)
 126                                                        {0x20, 0x60, 0x37, 0x5C, 0xFF},
 127                                                        {0x20, 0x82, 0x37, 0x5C, 0xFF},
 128                                                        {0x20, 0x82, 0x37, 0x5C, 0x00}, // position bleu (AA)
 129                                                        {0x20, 0x4C, 0x37, 0xA0, 0x00},
 130                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00}, // position DE REPOS 
 131                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 132                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 133                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 134                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00} },
 135                                                      
 136                                                      { {0x0B, 0x81, 0x39, 0x66, 0xFF}, // position balance (pince fermée)
 137                                                        {0x1C, 0x60, 0x31, 0x5C, 0xFF},
 138                                                        {0x1C, 0x7E, 0x31, 0x5C, 0xFF},
 139                                                        {0x1C, 0x7E, 0x31, 0x5C, 0x00}, // position vert (C)
 140                                                        {0x1C, 0x4C, 0x31, 0xA0, 0x00},
 141                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00}, // position DE REPOS
 142                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 143                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 144                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 145                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00} },
 146          
 147                                                      { {0x0B, 0x81, 0x39, 0x66, 0xFF}, // position balance (pince fermée)
 148                                                        {0x18, 0x60, 0x2D, 0x5C, 0xFF},
 149                                                        {0x18, 0x7C, 0x2D, 0x5C, 0xFF},
 150                                                        {0x18, 0x7C, 0x2D, 0x5C, 0x00}, // position rouge (9V)
 151                                                        {0x18, 0x4C, 0x2D, 0xA0, 0x00},
 152                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00}, // position DE REPOS
 153                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 154                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 155                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00},
 156                                                        {0x10, 0x4C, 0x00, 0xA0, 0x00} } };
 157          
 158          // *************************************************************************************************
 159          // VARIABLES LOCALES
 160          // *************************************************************************************************
 161          
 162          
 163          // *************************************************************************************************
 164          void main(void)
 165          //
 166          //  Auteur: John-William Lebel
 167          //
 168          //  Description: Appelé lorsque le programme démarre
 169          //  Paramètres d'entrées  : Aucun
 170          //  Paramètres de sortie  : Aucun
 171          //  Notes                 : Aucune
 172          //
 173          // *************************************************************************************************
 174          {
 175   1          vInitPortSerie();     // init the serial port to utilize the RxTx232 comunication with the pic16F88
 176   1          vInitLCD();           // init the lcd
C51 COMPILER V9.53.0.0   PROJETFINALMAIN                                                   12/05/2019 16:48:53 PAGE 4   

 177   1          initTimer50ms();      // init the timer0
 178   1          vAfficheLCDComplet(lcdInitializationContent);         // initialize the content of the lcd
 179   1          vInitInterrupt();     // init interrupt on serial 0
 180   1          
 181   1          while(1)
 182   1          {
 183   2            
 184   2              if(isOperating())   // the movements of the robot arm are automatic
 185   2              {
 186   3                  if(isTrameReceived())
 187   3                  {
 188   4                      currentArmState.base = readMemoryI2C(&currentSequenceIndexes.sequence, &currentSequenceInd
             -exes.step, BASE);
 189   4                      currentArmState.shoulder = readMemoryI2C(&currentSequenceIndexes.sequence, &currentSequenc
             -eIndexes.step, SHOULDER);
 190   4                      currentArmState.elbow = readMemoryI2C(&currentSequenceIndexes.sequence, &currentSequenceIn
             -dexes.step, ELBOW);
 191   4                      currentArmState.wrist = readMemoryI2C(&currentSequenceIndexes.sequence, &currentSequenceIn
             -dexes.step, WRIST);
 192   4                      currentArmState.grip = readMemoryI2C(&currentSequenceIndexes.sequence, &currentSequenceInd
             -exes.step, GRIP);
 193   4                  }
 194   3              }
 195   2              else              // the movements of the robot arm are manual; we need to read the keyboard
 196   2              {
 197   3                  handleKey(readKeyboardI2C(), &keyboardManualSettings, &currentArmState, &currentSequenceIndexes);   /
             -/ read the keyboard and update the variables accordingly
 198   3              }
 199   2              
 200   2              // ... gotta finish what happens next!
 201   2              if(TF0 == 1)
 202   2              {
 203   3                  vUpdateCompteurTimer0(&stCompteur);
 204   3              }
 205   2              
 206   2              if(stCompteur.ucCompteur300ms > 5)
 207   2              {
 208   3                  stCompteur.ucCompteur300ms = 0;
 209   3                  connectionStateString = LCD_DELTA_OFFLINE_VALUE;
 210   3              }
 211   2              
 212   2              if(stCompteur.ucCompteur200ms > 3)
 213   2              {
 214   3                  stCompteur.ucCompteur200ms = 0;
 215   3                  printLcdDeltaCharacters();
 216   3              }
 217   2              
 218   2              if(stCompteur.ucCompteur2sec > 39)
 219   2              {
 220   3                  stCompteur.ucCompteur2sec = 0;
 221   3                  handleSequence(&trame, &currentSequenceIndexes, &weightType);
 222   3              }
 223   2              
 224   2              if(isTrameReceived())
 225   2              {
 226   3                  stCompteur.ucCompteur300ms = 0;
 227   3                  connectionStateString = LCD_DELTA_ONLINE_VALUE;
 228   3                
 229   3                  resetIsTrameReceived();
 230   3                  vSendTrame(&currentArmState);
 231   3              }
 232   2              
C51 COMPILER V9.53.0.0   PROJETFINALMAIN                                                   12/05/2019 16:48:53 PAGE 5   

 233   2              vCircularBuffer(&trame);
 234   2          }
 235   1      }
 236          
 237          void printLcdDeltaCharacters()
 238          {
 239   1          printLcdDeltaMotors(&currentArmState);
 240   1          printLcdDeltaTrame(&trame);
 241   1          printLcdDeltaWeightType(&weightType);
 242   1          printLcdDeltaManualSettings(&keyboardManualSettings);
 243   1          printLcdCurrentSequenceStep(&currentSequenceIndexes);
 244   1          printLcdDeltaConnectionState(connectionStateString);
 245   1      }
 246          
 247          unsigned char readMemoryI2C(unsigned char* sequence, unsigned char* step, unsigned char armIndex)
 248          {
 249   1          unsigned int memoryAddress = ((((unsigned int)*sequence) * 50) + (*step * 5) + armIndex);
 250   1          return ucLireMemI2C(memoryAddress);
 251   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    475    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =    455       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
