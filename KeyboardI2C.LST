C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/06/2019 19:24:07 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE KEYBOARDI2C
OBJECT MODULE PLACED IN KeyboardI2C.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE KeyboardI2C.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*****************************Timer0 handling*******************************/
   2          /*
   3              Nom du fichier: Keyboard.c
   4              Auteur : John-William Lebel
   5          
   6              Date de création: 2019-12-02
   7          
   8              Fonction(s) nécessaire(s) pour intercepter et gérer les touches du clavier I2C
   9          
  10          
  11          *****************************************************************************************/
  12          #include "_DS89C450Modifie.h"       // Définition des bits et des registres du microcontrôleur
  13          #include "_DeclarationGenerale.h"
  14          #include "ProjectDefinitions.h"
  15          #include "KeyboardI2C.h"
  16          #include "I2C.h"
  17          #include "SequenceHandler.h"
  18          
  19          // Prototypes privés
  20          void vManualIncrementMotor(struct STKeyboardManualSettings* stpKeyboardManualSettings, struct STArmState* 
             -stpCurrentArmState, char cDirection);
  21          void vHandleMotorValueOverflow(unsigned char* ucpMotorValue, char* cpDirection);
  22          
  23          unsigned char ucKeyboardCharacters[16] = {'1', '2', '3', 'A',
  24                                                  '4', '5', '6', 'B',
  25                                                  '7', '8', '9', 'C',
  26                                                  '*', '0', '#', 'D'};
  27          
  28          
  29          // Implémentation fonctions
  30          unsigned char* ucpReadKeyboardI2C()
  31          {
  32   1          unsigned char ucKey = ' ';
  33   1          unsigned char ucAckValue = 0;
  34   1          
  35   1          if(!P1_2)
  36   1          {
  37   2              vStartBitI2C();
  38   2              ucAckValue = ucEcrire8BitsI2C(KEYBOARD_ADDRESS_I2C + 1);
  39   2              if(ucAckValue)
  40   2              {
  41   3                  return &ucKey; // return space if noAcks were detected
  42   3              }
  43   2              ucKey = ucLire8BitsI2C(0xFF);  // read with noAck
  44   2              vStopBitI2C();
  45   2              
  46   2              ucKey = ucKeyboardCharacters[ucKey % 16];
  47   2          }
  48   1          
  49   1          return &ucKey;
  50   1      }
  51          
  52          void vHandleKey(unsigned char* ucpKey, struct STKeyboardManualSettings* stpKeyboardManualSettings, struct 
             -STArmState* stpCurrentArmState, struct STSequenceStep* stpCurrentSequenceIndexes)
  53          {
C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/06/2019 19:24:07 PAGE 2   

  54   1          switch(*ucpKey)
  55   1          {
  56   2              case '1':
  57   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_0;
  58   2                  break;
  59   2              case '2':
  60   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_1;
  61   2                  break;
  62   2              case '3':
  63   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_2;
  64   2                  break;
  65   2              case '4':
  66   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_3;
  67   2                  break;
  68   2              case '5':
  69   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_4;
  70   2                  break;
  71   2              case '0':
  72   2                  stpKeyboardManualSettings->ucManualMovingSpeed = (stpKeyboardManualSettings->ucManualMovingSpe
             -ed + 4) % 20;
  73   2                  break;
  74   2              
  75   2              case '*':
  76   2                  vManualIncrementMotor(stpKeyboardManualSettings, stpCurrentArmState, -1);
  77   2                  break;
  78   2              case '#':
  79   2                  vManualIncrementMotor(stpKeyboardManualSettings, stpCurrentArmState, 1);
  80   2                  break;
  81   2              
  82   2              case 'A':
  83   2                  vSetOperatingState(WARM_UP_SETUP_OPERATING_STATE);
  84   2                  break;
  85   2              case 'B':
  86   2                  stpCurrentArmState->ucBase = 0x10;
  87   2                  stpCurrentArmState->ucShoulder = 0x4C;
  88   2                  stpCurrentArmState->ucElbow = 0x00;
  89   2                  stpCurrentArmState->ucWrist = 0x55;
  90   2                  stpCurrentArmState->ucGrip = 0x00;
  91   2                  break;
  92   2              
  93   2              case 'C':
  94   2                  stpCurrentSequenceIndexes->ucSequence = (stpCurrentSequenceIndexes->ucSequence + 1) % 7;
  95   2                  stpCurrentSequenceIndexes->ucStep = 0;
  96   2                  break;
  97   2              case 'D':
  98   2                  stpCurrentSequenceIndexes->ucStep = (stpCurrentSequenceIndexes->ucStep + 1) % 10;
  99   2                  break;
 100   2                  
 101   2          }
 102   1      }
 103          
 104          void vManualIncrementMotor(struct STKeyboardManualSettings* stpKeyboardManualSettings, struct STArmState* 
             -stpCurrentArmState, char cDirection)
 105          {
 106   1          switch(stpKeyboardManualSettings->ucManualySelectedMotor)
 107   1          {
 108   2            case MOTOR_0:
 109   2                stpCurrentArmState->ucBase += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) * cDi
             -rection);
 110   2                vHandleMotorValueOverflow(&(stpCurrentArmState->ucBase), &cDirection);
 111   2                break;
 112   2            case MOTOR_1:
C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/06/2019 19:24:07 PAGE 3   

 113   2                stpCurrentArmState->ucShoulder += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) *
             - cDirection);
 114   2                vHandleMotorValueOverflow(&(stpCurrentArmState->ucShoulder), &cDirection);
 115   2                break;
 116   2            case MOTOR_2:
 117   2                stpCurrentArmState->ucElbow += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) * cD
             -irection);
 118   2                vHandleMotorValueOverflow(&(stpCurrentArmState->ucElbow), &cDirection);
 119   2                break;
 120   2            case MOTOR_3:
 121   2                stpCurrentArmState->ucWrist += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) * cD
             -irection);
 122   2                vHandleMotorValueOverflow(&(stpCurrentArmState->ucWrist), &cDirection);
 123   2                break;
 124   2            case MOTOR_4:
 125   2                stpCurrentArmState->ucGrip += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) * cDi
             -rection);
 126   2                vHandleMotorValueOverflow(&(stpCurrentArmState->ucGrip), &cDirection);
 127   2                break;
 128   2          }
 129   1      }
 130          
 131          void vHandleMotorValueOverflow(unsigned char* ucpMotorValue, char* cpDirection)
 132          {
 133   1          if(*cpDirection == 1 && *ucpMotorValue > 205)
 134   1          {
 135   2              *ucpMotorValue = 205;
 136   2          }
 137   1          else if(*cpDirection == -1 && *ucpMotorValue > 205)
 138   1          {
 139   2              *ucpMotorValue = 0;
 140   2          }
 141   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    892    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      26
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
