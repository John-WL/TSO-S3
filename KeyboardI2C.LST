C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/09/2019 16:05:16 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE KEYBOARDI2C
OBJECT MODULE PLACED IN KeyboardI2C.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE KeyboardI2C.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*****************************Timer0 handling*******************************/
   2          /*
   3              Nom du fichier: Keyboard.c
   4              Auteur : John-William Lebel
   5          
   6              Date de création: 2019-12-02
   7          
   8              Fonction(s) nécessaire(s) pour intercepter et gérer les touches du clavier I2C
   9          
  10          
  11          *****************************************************************************************/
  12          #include "_DS89C450Modifie.h"       // Définition des bits et des registres du microcontrôleur
  13          #include "_DeclarationGenerale.h"
  14          #include "ProjectDefinitions.h"
  15          #include "KeyboardI2C.h"
  16          #include "I2C.h"
  17          #include "SequenceHandler.h"
  18          
  19          // Prototypes privés
  20          void vManualIncrementMotor(struct STKeyboardManualSettings* stpKeyboardManualSettings, struct STArmState* 
             -stpCurrentArmState, char cDirection);
  21          void vHandleMotorValueOverflow(unsigned char* ucpMotorValue, char* cpDirection);
  22          
  23          unsigned char ucKeyboardCharacters[16] = {'1', '2', '3', 'A',
  24                                                  '4', '5', '6', 'B',
  25                                                  '7', '8', '9', 'C',
  26                                                  '*', '0', '#', 'D'};
  27          
  28          
  29          // Implémentation fonctions
  30          unsigned char* ucpReadKeyboardI2C()
  31          {
  32   1          unsigned char ucKey = ' ';
  33   1          unsigned char ucAckValue = 0;
  34   1          
  35   1          if(!P1_2)
  36   1          {
  37   2              vStartBitI2C();
  38   2              ucAckValue = ucEcrire8BitsI2C(KEYBOARD_ADDRESS_I2C + 1);
  39   2              if(ucAckValue)
  40   2              {
  41   3                  return &ucKey; // return space if noAcks were detected
  42   3              }
  43   2              ucKey = ucLire8BitsI2C(0xFF);  // read with noAck
  44   2              vStopBitI2C();
  45   2              
  46   2              ucKey = ucKeyboardCharacters[ucKey % 16];
  47   2          }
  48   1          
  49   1          return &ucKey;
  50   1      }
  51          
  52          void vHandleKey(unsigned char* ucpKey,
  53              struct STKeyboardManualSettings* stpKeyboardManualSettings,
  54              struct STArmState* stpCurrentArmState,
C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/09/2019 16:05:16 PAGE 2   

  55              struct STSequenceStep* stpCurrentSequenceIndexes)
  56          {
  57   1          switch(*ucpKey)
  58   1          {
  59   2              case '1':
  60   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_0;
  61   2                  break;
  62   2              case '2':
  63   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_1;
  64   2                  break;
  65   2              case '3':
  66   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_2;
  67   2                  break;
  68   2              case '4':
  69   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_3;
  70   2                  break;
  71   2              case '5':
  72   2                  stpKeyboardManualSettings->ucManualySelectedMotor = MOTOR_4;
  73   2                  break;
  74   2              case '0':
  75   2                  stpKeyboardManualSettings->ucManualMovingSpeed = (stpKeyboardManualSettings->ucManualMovingSpe
             -ed + 4) % 20;
  76   2                  break;
  77   2              
  78   2              case '*':
  79   2                  vManualIncrementMotor(stpKeyboardManualSettings, stpCurrentArmState, -1);
  80   2                  break;
  81   2              case '#':
  82   2                  vManualIncrementMotor(stpKeyboardManualSettings, stpCurrentArmState, 1);
  83   2                  break;
  84   2              
  85   2              case 'A':
  86   2                  vSetOperatingState(WARM_UP_SETUP_OPERATING_STATE);
  87   2                  break;
  88   2              case 'B':
  89   2                  stpCurrentArmState->ucBase = 0x10;
  90   2                  stpCurrentArmState->ucShoulder = 0x4C;
  91   2                  stpCurrentArmState->ucElbow = 0x00;
  92   2                  stpCurrentArmState->ucWrist = 0x55;
  93   2                  stpCurrentArmState->ucGrip = 0x00;
  94   2                  break;
  95   2              
  96   2              case 'C':
  97   2                  stpCurrentSequenceIndexes->ucSequence = (stpCurrentSequenceIndexes->ucSequence + 1) % 7;
  98   2                  stpCurrentSequenceIndexes->ucStep = 0;
  99   2                  break;
 100   2              case 'D':
 101   2                  stpCurrentSequenceIndexes->ucStep = (stpCurrentSequenceIndexes->ucStep + 1) % 10;
 102   2                  break;
 103   2                  
 104   2          }
 105   1      }
 106          
 107          void vManualIncrementMotor(struct STKeyboardManualSettings* stpKeyboardManualSettings, struct STArmState* 
             -stpCurrentArmState, char cDirection)
 108          {
 109   1          switch(stpKeyboardManualSettings->ucManualySelectedMotor)
 110   1          {
 111   2              case MOTOR_0:
 112   2                  stpCurrentArmState->ucBase += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) * c
             -Direction);
 113   2                  vHandleMotorValueOverflow(&(stpCurrentArmState->ucBase), &cDirection);
C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/09/2019 16:05:16 PAGE 3   

 114   2                  break;
 115   2              case MOTOR_1:
 116   2                  stpCurrentArmState->ucShoulder += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed)
             - * cDirection);
 117   2                  vHandleMotorValueOverflow(&(stpCurrentArmState->ucShoulder), &cDirection);
 118   2                  break;
 119   2              case MOTOR_2:
 120   2                  stpCurrentArmState->ucElbow += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) * 
             -cDirection);
 121   2                  vHandleMotorValueOverflow(&(stpCurrentArmState->ucElbow), &cDirection);
 122   2                  break;
 123   2              case MOTOR_3:
 124   2                  stpCurrentArmState->ucWrist += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) * 
             -cDirection);
 125   2                  vHandleMotorValueOverflow(&(stpCurrentArmState->ucWrist), &cDirection);
 126   2                  break;
 127   2              case MOTOR_4:
 128   2                  stpCurrentArmState->ucGrip += (char)(((int)stpKeyboardManualSettings->ucManualMovingSpeed) * c
             -Direction);
 129   2                  vHandleMotorValueOverflow(&(stpCurrentArmState->ucGrip), &cDirection);
 130   2                  break;
 131   2          }
 132   1      }
 133          
 134          void vHandleMotorValueOverflow(unsigned char* ucpMotorValue, char* cpDirection)
 135          {
 136   1          if(*cpDirection == 1 && *ucpMotorValue > 205)
 137   1          {
 138   2              *ucpMotorValue = 205;
 139   2          }
 140   1          else if(*cpDirection == -1 && *ucpMotorValue > 205)
 141   1          {
 142   2              *ucpMotorValue = 0;
 143   2          }
 144   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    892    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      26
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
