C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/02/2019 22:03:20 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE KEYBOARDI2C
OBJECT MODULE PLACED IN KeyboardI2C.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE KeyboardI2C.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*****************************Timer0 handling*******************************/
   2          /*
   3              Nom du fichier: Keyboard.c
   4              Auteur : John-William Lebel
   5          
   6              Date de création: 2019-12-02
   7          
   8              Fonction(s) nécessaire(s) pour intercepter et gérer les touches du clavier I2C
   9          
  10          
  11          *****************************************************************************************/
  12          #include "ds89c450.h"
  13          #include "ProjectDefinitions.h"
  14          #include "KeyboardI2C.h"
  15          #include "I2C.h"
  16          
  17          // Prototypes privés
  18          void manualIncrementMotor(struct KeyboardManualSettings* keyboardManualSettings, struct ArmState* currentA
             -rmState, char direction);
  19          void handleMotorValueOverflow(unsigned char* motorValue, unsigned char* direction);
  20          
  21          unsigned char keyboardCharacters[16] = {'1', '2', '3', 'A',
  22                                                  '4', '5', '6', 'B',
  23                                                  '7', '8', '9', 'C',
  24                                                  '*', '0', '#', 'D'};
  25          
  26          
  27          // Implémentation fonctions
  28          unsigned char* readKeyboardI2C()
  29          {
  30   1          unsigned char key = ' ';
  31   1          unsigned char ackValue = 0;
  32   1          
  33   1          if(!P1_2)
  34   1          {
  35   2              vI2CStartBit();
  36   2              ackValue = ucEcrire8BitsI2C(KEYBOARD_ADDRESS_I2C + 1);
  37   2              if(ackValue)
  38   2              {
  39   3                  return &key; // return space if noAcks were detected
  40   3              }
  41   2              key = ucLire8BitsI2C(0xFF);  // read with noAck
  42   2              vI2CStopBit();
  43   2              
  44   2              key = keyboardCharacters[key % 16];
  45   2          }
  46   1          
  47   1          return &key;
  48   1      }
  49          
  50          void handleKey(unsigned char* key, struct KeyboardManualSettings* keyboardManualSettings, struct ArmState*
             - currentArmState)
  51          {
  52   1          switch(*key)
  53   1          {
C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/02/2019 22:03:20 PAGE 2   

  54   2              case '1':
  55   2                  keyboardManualSettings->manualySelectedMotor = MOTOR_0;
  56   2                  break;
  57   2              case '2':
  58   2                  keyboardManualSettings->manualySelectedMotor = MOTOR_1;
  59   2                  break;
  60   2              case '3':
  61   2                  keyboardManualSettings->manualySelectedMotor = MOTOR_2;
  62   2                  break;
  63   2              case '4':
  64   2                  keyboardManualSettings->manualySelectedMotor = MOTOR_3;
  65   2                  break;
  66   2              case '5':
  67   2                  keyboardManualSettings->manualySelectedMotor = MOTOR_4;
  68   2                  break;
  69   2              case '0':
  70   2                  keyboardManualSettings->manualMovingSpeed = (keyboardManualSettings->manualMovingSpeed + 4) % 
             -20;
  71   2                  break;
  72   2              
  73   2              case '*':
  74   2                  manualIncrementMotor(keyboardManualSettings, currentArmState, -1);
  75   2                  break;
  76   2              case '#':
  77   2                  manualIncrementMotor(keyboardManualSettings, currentArmState, 1);
  78   2                  break;
  79   2              case 'A':
  80   2                  // NEEDING IMPLEMENTATION! This line is supposed to make the robot arm warm up
  81   2                  break;
  82   2          }
  83   1      }
  84          
  85          void manualIncrementMotor(struct KeyboardManualSettings* keyboardManualSettings, struct ArmState* currentA
             -rmState, char direction)
  86          {
  87   1          switch(keyboardManualSettings->manualySelectedMotor)
  88   1          {
  89   2            case MOTOR_0:
  90   2                currentArmState->base += (char)(((int)keyboardManualSettings->manualMovingSpeed) * direction);
  91   2                handleMotorValueOverflow(&(currentArmState->base), &direction);
  92   2                break;
  93   2            case MOTOR_1:
  94   2                currentArmState->shoulder += (char)(((int)keyboardManualSettings->manualMovingSpeed) * direction
             -);
  95   2                handleMotorValueOverflow(&(currentArmState->shoulder), &direction);
  96   2                break;
  97   2            case MOTOR_2:
  98   2                currentArmState->elbow += (char)(((int)keyboardManualSettings->manualMovingSpeed) * direction);
  99   2                handleMotorValueOverflow(&(currentArmState->elbow), &direction);
 100   2                break;
 101   2            case MOTOR_3:
 102   2                currentArmState->wrist += (char)(((int)keyboardManualSettings->manualMovingSpeed) * direction);
 103   2                handleMotorValueOverflow(&(currentArmState->wrist), &direction);
 104   2                break;
 105   2            case MOTOR_4:
 106   2                currentArmState->grip += (char)(((int)keyboardManualSettings->manualMovingSpeed) * direction);
 107   2                handleMotorValueOverflow(&(currentArmState->grip), &direction);
 108   2                break;
 109   2          }
 110   1      }
 111          
 112          void handleMotorValueOverflow(unsigned char* motorValue, unsigned char* direction)
C51 COMPILER V9.53.0.0   KEYBOARDI2C                                                       12/02/2019 22:03:20 PAGE 3   

 113          {
 114   1          if(*direction == 1 && *motorValue > 205)
 115   1          {
 116   2              *motorValue = 205;
 117   2          }
 118   1          else if(*direction == -1 && *motorValue > 205)
 119   1          {
 120   2              *motorValue = 0;
 121   2          }
 122   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    749    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
