C51 COMPILER V9.53.0.0   TYPECONVERSION                                                    12/09/2019 15:01:06 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE TYPECONVERSION
OBJECT MODULE PLACED IN TypeConversion.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE TypeConversion.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(
                    -2)

line level    source

   1          /*****************************Type conversion handling*******************************/
   2          /*
   3              Nom du fichier: TypeConversion.c
   4              Auteur : John-William Lebel
   5          
   6              Date de création: 2019-11-29
   7          
   8              Fonction(s) utile(s) pour convertir certains types en d'autres
   9          
  10          
  11          *****************************************************************************************/
  12          
  13          //-------------- header files  -----------------
  14          #include "_DS89C450Modifie.h"       // Définition des bits et des registres du microcontrôleur
  15          #include "_DeclarationGenerale.h"
  16          #include "TypeConversion.h"
  17          
  18          // Prédéclarations privées
  19          void vHalfCharToHexaDecimal(unsigned char* ucpNumberToEvaluate);
  20          
  21          
  22          // *************************************************************************************************
  23          unsigned char* ucpUnsignedCharToAsciiHexaDecimal(unsigned char* ucpNumberToEvaluate, unsigned char ucDigit
             -Index)
  24          //
  25          //  Auteur: John-William Lebel
  26          //
  27          //  Description: Convert an unsigned char variable into an ascii encoded hexadecimal value. If digitIndex 
             -== 0,
  28          //                then the msb is returned (4 bits). If digitIndex == 1, then the lsb is returned (4 bits too).
  29          //                If digitIndex == anything else, then the character ' ' is returned.
  30          //  Paramètres d'entrées  : numberToEvaluate, digitIndex
  31          //  Paramètres de sortie  : an ascii encoded hexadecimal value
  32          //  Notes                 : Aucune
  33          //
  34          // *************************************************************************************************
  35          {
  36   1          unsigned char* ucpResult;
  37   1        
  38   1          if(ucDigitIndex == 0)   // need to change the 0 for the "define", and include the right file
  39   1          {
  40   2              *ucpResult = *ucpNumberToEvaluate >> 4;
  41   2          }
  42   1          else if(ucDigitIndex == 1)
  43   1          {
  44   2              *ucpResult = (*ucpNumberToEvaluate) & 0x0F;
  45   2          }
  46   1          else
  47   1          {
  48   2              *ucpResult = ' ';
  49   2          }
  50   1          vHalfCharToHexaDecimal(ucpResult);
  51   1          
  52   1          return ucpResult;
C51 COMPILER V9.53.0.0   TYPECONVERSION                                                    12/09/2019 15:01:06 PAGE 2   

  53   1      }
  54          
  55          // *************************************************************************************************
  56          unsigned char* ucpUnsignedCharToAsciiDecimal(unsigned char* ucpNumberToEvaluate, unsigned char ucDigitInde
             -x)
  57          //
  58          //  Auteur: John-William Lebel
  59          //
  60          //  Description: Convert an unsigned char variable into an ascii encoded decimal value. If digitIndex == 0
             -,
  61          //                then the 1st digit is returned. If digitIndex == 1, then the 2nd digit is returned.
  62          //                If digitIndex == 2, the 3rd digit is returned. If digitIndex == anything else, then
  63          //                the character ' ' is returned.
  64          //  Paramètres d'entrées  : numberToEvaluate, digitIndex
  65          //  Paramètres de sortie  : an ascii encoded decimal value
  66          //  Notes                 : Aucune
  67          //
  68          // *************************************************************************************************
  69          {
  70   1          unsigned char* ucpResult;
  71   1        
  72   1          if(ucDigitIndex == 0)
  73   1          {
  74   2              *ucpResult = '0' + (*ucpNumberToEvaluate / 100);
  75   2          }
  76   1          else if(ucDigitIndex == 1)
  77   1          {
  78   2              *ucpResult = '0' + (*ucpNumberToEvaluate / 10);
  79   2          }
  80   1          else if(ucDigitIndex == 2)
  81   1          {
  82   2              *ucpResult = '0' + (*ucpNumberToEvaluate % 10);
  83   2          }
  84   1          else
  85   1          {
  86   2              *ucpResult = ' ';
  87   2          }
  88   1          
  89   1          return ucpResult;
  90   1      }
  91          
  92          // *************************************************************************************************
  93          unsigned char* ucpWeightTypeToString(unsigned char* ucpWeightTypeIndex)
  94          //
  95          //  Auteur: John-William Lebel
  96          //
  97          //  Description: Convert an unsigned char variable that represents the type of weight (wheither it's red,
  98          //                green, or blue), which can be seen as an index, into its corresponding name in the string format
  99          //  Paramètres d'entrées  : weightTypeIndex
 100          //  Paramètres de sortie  : the name of the weight type
 101          //  Notes                 : Aucune
 102          //
 103          // *************************************************************************************************
 104          {
 105   1          unsigned char* ucpResult;
 106   1          
 107   1          if(*ucpWeightTypeIndex == BLUE_WEIGHT)
 108   1          {
 109   2              ucpResult = "Bleu ";
 110   2          }
 111   1          else if(*ucpWeightTypeIndex == GREEN_WEIGHT)
 112   1          {
C51 COMPILER V9.53.0.0   TYPECONVERSION                                                    12/09/2019 15:01:06 PAGE 3   

 113   2              ucpResult = "Vert ";
 114   2          }
 115   1          else if(*ucpWeightTypeIndex == RED_WEIGHT)
 116   1          {
 117   2              ucpResult = "Rouge";
 118   2          }
 119   1          else
 120   1          {
 121   2              ucpResult = "Aucun";
 122   2          }
 123   1          
 124   1          return ucpResult;
 125   1      }
 126          
 127          // *************************************************************************************************
 128          void vHalfCharToHexaDecimal(unsigned char* ucpNumberToEvaluate)
 129          //
 130          //  Auteur: John-William Lebel
 131          //
 132          //  Description: Convert an unsigned char variable smaller than 0x10 into an hexadecimal value in ascii.
 133          //  Paramètres d'entrées  : numberToEvaluate
 134          //  Paramètres de sortie  : an ascii encoded hexadecimal value
 135          //  Notes                 : Aucune
 136          //
 137          // *************************************************************************************************
 138          {
 139   1          if(*ucpNumberToEvaluate <= 9)
 140   1          {
 141   2              *ucpNumberToEvaluate = '0' + *ucpNumberToEvaluate;
 142   2          }
 143   1          else if(*ucpNumberToEvaluate <= 0x0F)
 144   1          {
 145   2              *ucpNumberToEvaluate = 'A' + (*ucpNumberToEvaluate - 0x0A);
 146   2          }
 147   1          else
 148   1          {
 149   2              *ucpNumberToEvaluate = ' ';
 150   2          }
 151   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    364    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =   ----      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
